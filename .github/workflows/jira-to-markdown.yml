name: Jira to Markdown Converter

on:
  workflow_dispatch:
    inputs:
      jira_ticket:
        description: 'Jira ticket key (e.g., PROJ-123)'
        required: true
        type: string
      output_path:
        description: 'Output path for markdown file (optional)'
        required: false
        default: 'docs/tickets'
        type: string

env:
  JIRA_BASE_URL: ${{ secrets.JIRA_BASE_URL }}
  JIRA_EMAIL: ${{ secrets.JIRA_EMAIL }}
  JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}

jobs:
  convert-jira-to-markdown:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: read
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        
    - name: Install dependencies
      run: |
        npm init -y
        npm install axios form-data
        
    - name: Create Jira to Markdown script
      run: |
        cat > jira-to-markdown.js << 'EOF'
        const axios = require('axios');
        const fs = require('fs');
        const path = require('path');
        const FormData = require('form-data');

        class JiraToMarkdown {
          constructor() {
            this.baseURL = process.env.JIRA_BASE_URL;
            this.email = process.env.JIRA_EMAIL;
            this.apiToken = process.env.JIRA_API_TOKEN;
            this.ticketKey = process.argv[2];
            this.outputPath = process.argv[3] || 'docs/tickets';
            
            if (!this.baseURL || !this.email || !this.apiToken) {
              throw new Error('Missing required environment variables');
            }
            
            this.auth = Buffer.from(`${this.email}:${this.apiToken}`).toString('base64');
          }

          async makeJiraRequest(endpoint) {
            try {
              const response = await axios.get(`${this.baseURL}/rest/api/3/${endpoint}`, {
                headers: {
                  'Authorization': `Basic ${this.auth}`,
                  'Accept': 'application/json',
                  'Content-Type': 'application/json'
                }
              });
              return response.data;
            } catch (error) {
              console.error(`Error making request to ${endpoint}:`, error.message);
              throw error;
            }
          }

          async downloadAttachment(attachment, ticketDir) {
            try {
              const response = await axios.get(attachment.content, {
                headers: {
                  'Authorization': `Basic ${this.auth}`
                },
                responseType: 'stream'
              });

              const filePath = path.join(ticketDir, 'attachments', attachment.filename);
              const writer = fs.createWriteStream(filePath);
              response.data.pipe(writer);

              return new Promise((resolve, reject) => {
                writer.on('finish', () => resolve(filePath));
                writer.on('error', reject);
              });
            } catch (error) {
              console.error(`Error downloading attachment ${attachment.filename}:`, error.message);
              return null;
            }
          }

          formatField(value) {
            if (!value) return 'N/A';
            if (typeof value === 'object') {
              if (value.displayName) return value.displayName;
              if (value.name) return value.name;
              if (value.value) return value.value;
              if (Array.isArray(value)) {
                return value.map(item => this.formatField(item)).join(', ');
              }
              return JSON.stringify(value, null, 2);
            }
            return value.toString();
          }

          convertJiraToMarkdown(content) {
            if (!content) return '';
            
            // Convert Jira markup to Markdown
            return content
              .replace(/\*([^*]+)\*/g, '**$1**')  // Bold
              .replace(/_([^_]+)_/g, '*$1*')      // Italic
              .replace(/\+([^+]+)\+/g, '`$1`')    // Code
              .replace(/\^([^^]+)\^/g, '<sup>$1</sup>') // Superscript
              .replace(/~([^~]+)~/g, '<sub>$1</sub>')   // Subscript
              .replace(/\{code(?::([^}]*))?\}(.*?)\{code\}/gs, '```$1\n$2\n```') // Code blocks
              .replace(/\{quote\}(.*?)\{quote\}/gs, '> $1') // Quotes
              .replace(/\[([^\]]+)\|([^\]]+)\]/g, '[$1]($2)') // Links
              .replace(/!([^!]+)!/g, '![]($1)');  // Images
          }

          async generateMarkdown(ticket, comments, attachments) {
            const fields = ticket.fields;
            let markdown = `# ${this.ticketKey}: ${fields.summary}\n\n`;
            
            // Metadata table
            markdown += `## Ticket Information\n\n`;
            markdown += `| Field | Value |\n`;
            markdown += `|-------|-------|\n`;
            markdown += `| **Key** | ${ticket.key} |\n`;
            markdown += `| **Type** | ${this.formatField(fields.issuetype)} |\n`;
            markdown += `| **Status** | ${this.formatField(fields.status)} |\n`;
            markdown += `| **Priority** | ${this.formatField(fields.priority)} |\n`;
            markdown += `| **Reporter** | ${this.formatField(fields.reporter)} |\n`;
            markdown += `| **Assignee** | ${this.formatField(fields.assignee)} |\n`;
            markdown += `| **Created** | ${new Date(fields.created).toLocaleString()} |\n`;
            markdown += `| **Updated** | ${new Date(fields.updated).toLocaleString()} |\n`;
            
            if (fields.labels && fields.labels.length > 0) {
              markdown += `| **Labels** | ${fields.labels.join(', ')} |\n`;
            }
            
            if (fields.components && fields.components.length > 0) {
              markdown += `| **Components** | ${fields.components.map(c => c.name).join(', ')} |\n`;
            }
            
            markdown += `\n`;

            // Description
            if (fields.description) {
              markdown += `## Description\n\n`;
              markdown += `${this.convertJiraToMarkdown(fields.description.content ? 
                fields.description.content.map(c => c.content?.map(cc => cc.text).join('') || '').join('\n') : 
                fields.description)}\n\n`;
            }

            // Custom fields
            const customFields = Object.entries(fields).filter(([key, value]) => 
              key.startsWith('customfield_') && value !== null
            );
            
            if (customFields.length > 0) {
              markdown += `## Custom Fields\n\n`;
              customFields.forEach(([key, value]) => {
                markdown += `- **${key}**: ${this.formatField(value)}\n`;
              });
              markdown += `\n`;
            }

            // Attachments
            if (attachments && attachments.length > 0) {
              markdown += `## Attachments\n\n`;
              attachments.forEach(attachment => {
                const relativePath = `./attachments/${attachment.filename}`;
                markdown += `- [${attachment.filename}](${relativePath}) (${attachment.size} bytes)\n`;
              });
              markdown += `\n`;
            }

            // Comments
            if (comments && comments.length > 0) {
              markdown += `## Comments\n\n`;
              comments.forEach((comment, index) => {
                const author = comment.author?.displayName || 'Unknown';
                const created = new Date(comment.created).toLocaleString();
                const body = this.convertJiraToMarkdown(comment.body?.content ?
                  comment.body.content.map(c => c.content?.map(cc => cc.text).join('') || '').join('\n') :
                  comment.body || '');
                
                markdown += `### Comment ${index + 1}\n`;
                markdown += `**Author**: ${author}  \n`;
                markdown += `**Date**: ${created}\n\n`;
                markdown += `${body}\n\n`;
                markdown += `---\n\n`;
              });
            }

            // Metadata footer
            markdown += `## Metadata\n\n`;
            markdown += `- **Generated**: ${new Date().toISOString()}\n`;
            markdown += `- **Source**: [${this.ticketKey}](${this.baseURL}/browse/${this.ticketKey})\n`;
            markdown += `- **Workflow**: GitHub Actions\n`;

            return markdown;
          }

          async run() {
            try {
              console.log(`Converting Jira ticket ${this.ticketKey} to Markdown...`);
              
              // Create output directory
              const ticketDir = path.join(this.outputPath, this.ticketKey);
              const attachmentsDir = path.join(ticketDir, 'attachments');
              
              if (!fs.existsSync(ticketDir)) {
                fs.mkdirSync(ticketDir, { recursive: true });
              }
              if (!fs.existsSync(attachmentsDir)) {
                fs.mkdirSync(attachmentsDir, { recursive: true });
              }

              // Fetch ticket data
              console.log('Fetching ticket data...');
              const ticket = await this.makeJiraRequest(`issue/${this.ticketKey}`);
              
              // Fetch comments
              console.log('Fetching comments...');
              const commentsData = await this.makeJiraRequest(`issue/${this.ticketKey}/comment`);
              const comments = commentsData.comments || [];
              
              // Download attachments
              console.log('Downloading attachments...');
              const attachments = ticket.fields.attachment || [];
              const downloadPromises = attachments.map(attachment => 
                this.downloadAttachment(attachment, ticketDir)
              );
              await Promise.all(downloadPromises);
              
              // Generate markdown
              console.log('Generating markdown...');
              const markdown = await this.generateMarkdown(ticket, comments, attachments);
              
              // Write markdown file
              const markdownPath = path.join(ticketDir, `${this.ticketKey}.md`);
              fs.writeFileSync(markdownPath, markdown);
              
              console.log(`âœ… Successfully converted ${this.ticketKey} to ${markdownPath}`);
              console.log(`ðŸ“ Attachments saved to: ${attachmentsDir}`);
              
              // Output for GitHub Actions using Environment Files
              const fs = require('fs');
              const outputFile = process.env.GITHUB_OUTPUT;
              if (outputFile) {
                fs.appendFileSync(outputFile, `markdown_path=${markdownPath}\n`);
                fs.appendFileSync(outputFile, `attachments_dir=${attachmentsDir}\n`);
              }
              
            } catch (error) {
              console.error('âŒ Error:', error.message);
              process.exit(1);
            }
          }
        }

        // Run the converter
        const converter = new JiraToMarkdown();
        converter.run();
        EOF
        
    - name: Convert Jira ticket to Markdown
      id: convert
      run: node jira-to-markdown.js "${{ github.event.inputs.jira_ticket }}" "${{ github.event.inputs.output_path }}"
      
    - name: Commit and push changes
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        # Check if there are any changes to commit
        if [ -n "$(git status --porcelain)" ]; then
          git add .
          git commit -m "Add Jira ticket ${{ github.event.inputs.jira_ticket }} as Markdown"
          git push
          echo "âœ… Changes committed and pushed successfully"
        else
          echo "â„¹ï¸ No changes to commit"
        fi
        
    - name: Create summary
      run: |
        echo "## Jira Ticket Conversion Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Ticket**: ${{ github.event.inputs.jira_ticket }}" >> $GITHUB_STEP_SUMMARY
        echo "**Output Path**: ${{ github.event.inputs.output_path }}" >> $GITHUB_STEP_SUMMARY
        echo "**Status**: âœ… Successfully converted" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "Files created:" >> $GITHUB_STEP_SUMMARY
        echo "- Markdown file: \`${{ github.event.inputs.output_path }}/${{ github.event.inputs.jira_ticket }}/${{ github.event.inputs.jira_ticket }}.md\`" >> $GITHUB_STEP_SUMMARY
        echo "- Attachments directory: \`${{ github.event.inputs.output_path }}/${{ github.event.inputs.jira_ticket }}/attachments/\`" >> $GITHUB_STEP_SUMMARY
